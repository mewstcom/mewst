# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sucker_punch` gem.
# Please instead update this file by running `bin/tapioca gem sucker_punch`.

# Include this in your tests to simulate
# a fake job queue. Jobs won't be executed
# as they normal would be the thread pool.
# They'll instead be pushed to a fake queue
# to be checked in a test environment.
#
# Include in your test_helper.rb:
#
# require 'sucker_punch/testing'
#
# In your application code:
#
#   LogJob.perform_async(1, 2, 3)
#
# In your tests:
#
#   LogJob.jobs => [{ "args" => [1, 2, 3]]
#
# source://sucker_punch//lib/sucker_punch/counter.rb#1
module SuckerPunch
  class << self
    # source://sucker_punch//lib/sucker_punch.rb#21
    def default_exception_handler(ex, klass, args); end

    # source://sucker_punch//lib/sucker_punch.rb#32
    def default_logger; end

    # source://sucker_punch//lib/sucker_punch.rb#13
    def exception_handler; end

    # source://sucker_punch//lib/sucker_punch.rb#17
    def exception_handler=(handler); end

    # source://sucker_punch//lib/sucker_punch.rb#28
    def logger; end

    # source://sucker_punch//lib/sucker_punch.rb#38
    def logger=(log); end

    # source://sucker_punch//lib/sucker_punch.rb#42
    def shutdown_timeout; end

    # source://sucker_punch//lib/sucker_punch.rb#47
    def shutdown_timeout=(timeout); end
  end
end

# source://sucker_punch//lib/sucker_punch/counter.rb#2
module SuckerPunch::Counter; end

# source://sucker_punch//lib/sucker_punch/counter.rb#17
class SuckerPunch::Counter::Busy
  include ::SuckerPunch::Counter::Utilities

  # @return [Busy] a new instance of Busy
  #
  # source://sucker_punch//lib/sucker_punch/counter.rb#30
  def initialize(queue_name); end

  # Returns the value of attribute counter.
  #
  # source://sucker_punch//lib/sucker_punch/counter.rb#18
  def counter; end

  class << self
    # source://sucker_punch//lib/sucker_punch/counter.rb#26
    def clear; end
  end
end

# source://sucker_punch//lib/sucker_punch/counter.rb#22
SuckerPunch::Counter::Busy::COUNTER = T.let(T.unsafe(nil), Concurrent::Map)

# source://sucker_punch//lib/sucker_punch/counter.rb#53
class SuckerPunch::Counter::Failed
  include ::SuckerPunch::Counter::Utilities

  # @return [Failed] a new instance of Failed
  #
  # source://sucker_punch//lib/sucker_punch/counter.rb#66
  def initialize(queue_name); end

  # Returns the value of attribute counter.
  #
  # source://sucker_punch//lib/sucker_punch/counter.rb#54
  def counter; end

  class << self
    # source://sucker_punch//lib/sucker_punch/counter.rb#62
    def clear; end
  end
end

# source://sucker_punch//lib/sucker_punch/counter.rb#58
SuckerPunch::Counter::Failed::COUNTER = T.let(T.unsafe(nil), Concurrent::Map)

# source://sucker_punch//lib/sucker_punch/counter.rb#35
class SuckerPunch::Counter::Processed
  include ::SuckerPunch::Counter::Utilities

  # @return [Processed] a new instance of Processed
  #
  # source://sucker_punch//lib/sucker_punch/counter.rb#48
  def initialize(queue_name); end

  # Returns the value of attribute counter.
  #
  # source://sucker_punch//lib/sucker_punch/counter.rb#36
  def counter; end

  class << self
    # source://sucker_punch//lib/sucker_punch/counter.rb#44
    def clear; end
  end
end

# source://sucker_punch//lib/sucker_punch/counter.rb#40
SuckerPunch::Counter::Processed::COUNTER = T.let(T.unsafe(nil), Concurrent::Map)

# source://sucker_punch//lib/sucker_punch/counter.rb#3
module SuckerPunch::Counter::Utilities
  # source://sucker_punch//lib/sucker_punch/counter.rb#12
  def decrement; end

  # source://sucker_punch//lib/sucker_punch/counter.rb#8
  def increment; end

  # source://sucker_punch//lib/sucker_punch/counter.rb#4
  def value; end
end

# Include this module in your job class
# to create asynchronous jobs:
#
# class LogJob
#   include SuckerPunch::Job
#   workers 4
#
#   def perform(*args)
#     # log the things
#   end
# end
#
# To trigger asynchronous job:
#
#   LogJob.perform_async(1, 2, 3)
#   LogJob.perform_in(60, 1, 2, 3) # `perform` will be executed 60 sec. later
#
# Note that perform_async is a class method, perform is an instance method.
#
# source://sucker_punch//lib/sucker_punch/job.rb#20
module SuckerPunch::Job
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::SuckerPunch::Job::ClassMethods

  # source://sucker_punch//lib/sucker_punch/job.rb#30
  def logger; end

  class << self
    # @private
    #
    # source://sucker_punch//lib/sucker_punch/job.rb#21
    def included(base); end
  end

  module GeneratedClassMethods
    def num_jobs_max; end
    def num_jobs_max=(value); end
    def num_jobs_max?; end
    def num_workers; end
    def num_workers=(value); end
    def num_workers?; end
  end

  module GeneratedInstanceMethods
    def num_jobs_max; end
    def num_jobs_max=(value); end
    def num_jobs_max?; end
    def num_workers; end
    def num_workers=(value); end
    def num_workers?; end
  end
end

# source://sucker_punch//lib/sucker_punch/job.rb#34
module SuckerPunch::Job::ClassMethods
  # source://sucker_punch//lib/sucker_punch/job.rb#60
  def __run_perform(*args, **_arg1); end

  # source://sucker_punch//lib/sucker_punch/job.rb#56
  def max_jobs(num); end

  # source://sucker_punch//lib/sucker_punch/job.rb#35
  def perform_async(*args, **_arg1); end

  # source://sucker_punch//lib/sucker_punch/job.rb#42
  def perform_in(interval, *args, **_arg2); end

  # source://sucker_punch//lib/sucker_punch/job.rb#52
  def workers(num); end
end

# source://sucker_punch//lib/sucker_punch/queue.rb#4
class SuckerPunch::Queue < ::Concurrent::Synchronization::LockableObject
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  include ::Concurrent::ExecutorService
  extend ::Forwardable

  # @return [Queue] a new instance of Queue
  #
  # source://sucker_punch//lib/sucker_punch/queue.rb#147
  def initialize(name, pool); end

  # source://sucker_punch//lib/sucker_punch/queue.rb#161
  def ==(other); end

  # source://sucker_punch//lib/sucker_punch/queue.rb#165
  def busy_workers; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def enqueued_jobs(*args, **_arg1, &block); end

  # source://sucker_punch//lib/sucker_punch/queue.rb#177
  def failed_jobs; end

  # @return [Boolean]
  #
  # source://sucker_punch//lib/sucker_punch/queue.rb#157
  def idle?; end

  # source://sucker_punch//lib/sucker_punch/queue.rb#169
  def idle_workers; end

  # source://sucker_punch//lib/sucker_punch/queue.rb#192
  def kill; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def max_length(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def max_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def min_length(*args, **_arg1, &block); end

  # Returns the value of attribute name.
  #
  # source://sucker_punch//lib/sucker_punch/queue.rb#125
  def name; end

  # source://sucker_punch//lib/sucker_punch/queue.rb#181
  def post(*args, **_arg1, &block); end

  # source://sucker_punch//lib/sucker_punch/queue.rb#173
  def processed_jobs; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def queue_length(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://sucker_punch//lib/sucker_punch/queue.rb#153
  def running?; end

  # source://sucker_punch//lib/sucker_punch/queue.rb#196
  def shutdown; end

  # :idletime,
  # :max_queue,
  # :largest_length,
  # :scheduled_task_count,
  # :completed_task_count,
  # :can_overflow?,
  # :remaining_capacity,
  # :running?,
  # :shuttingdown?
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def total_workers(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def wait_for_termination(*args, **_arg1, &block); end

  protected

  # source://sucker_punch//lib/sucker_punch/queue.rb#203
  def pool; end

  class << self
    # source://sucker_punch//lib/sucker_punch/queue.rb#33
    def all; end

    # source://sucker_punch//lib/sucker_punch/queue.rb#41
    def clear; end

    # source://sucker_punch//lib/sucker_punch/queue.rb#19
    def find_or_create(name, num_workers = T.unsafe(nil), num_jobs_max = T.unsafe(nil)); end

    # source://sucker_punch//lib/sucker_punch/queue.rb#74
    def shutdown_all; end

    # source://sucker_punch//lib/sucker_punch/queue.rb#51
    def stats; end

    # source://sucker_punch//lib/sucker_punch/queue.rb#112
    def wait; end
  end
end

# source://sucker_punch//lib/sucker_punch/queue.rb#10
SuckerPunch::Queue::DEFAULT_EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Unlimited
#
# source://sucker_punch//lib/sucker_punch/queue.rb#8
SuckerPunch::Queue::DEFAULT_MAX_QUEUE_SIZE = T.let(T.unsafe(nil), Integer)

# source://sucker_punch//lib/sucker_punch/queue.rb#72
SuckerPunch::Queue::PAUSE_TIME = T.let(T.unsafe(nil), Float)

# source://sucker_punch//lib/sucker_punch/queue.rb#17
SuckerPunch::Queue::QUEUES = T.let(T.unsafe(nil), Concurrent::Map)

# source://sucker_punch//lib/sucker_punch.rb#10
SuckerPunch::RUNNING = T.let(T.unsafe(nil), Concurrent::AtomicBoolean)

# source://sucker_punch//lib/sucker_punch/railtie.rb#2
class SuckerPunch::Railtie < ::Rails::Railtie; end

# source://sucker_punch//lib/sucker_punch/version.rb#2
SuckerPunch::VERSION = T.let(T.unsafe(nil), String)
