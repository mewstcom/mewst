# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `debug` gem.
# Please instead update this file by running `bin/tapioca gem debug`.

class BasicObject
  def singleton_method_added(mid); end
end

class Binding
  def b(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end
  def break(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end
end

module DEBUGGER__
  class << self
    def add_catch_breakpoint(pat); end
    def add_line_breakpoint(file, line, **kw); end
    def capture_frames(_arg0); end
    def check_dir_authority(path); end
    def check_loglevel(level); end
    def commands; end
    def compare_path(a, b); end
    def create_unix_domain_socket_name(base_dir = T.unsafe(nil)); end
    def create_unix_domain_socket_name_prefix(base_dir = T.unsafe(nil)); end
    def debug(&b); end
    def frame_depth; end
    def help; end
    def helps; end
    def info(msg); end
    def initialize_session(&init_ui); end
    def load_rc; end
    def log(level, msg); end
    def open(host: T.unsafe(nil), port: T.unsafe(nil), sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end
    def open_tcp(port:, host: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end
    def open_unix(sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end
    def parse_help; end
    def require_location; end
    def safe_inspect(obj, max_length: T.unsafe(nil), short: T.unsafe(nil)); end
    def setup_initial_suspend; end
    def start(nonstop: T.unsafe(nil), **kw); end
    def step_in(&b); end
    def unix_domain_socket_dir; end
    def unix_domain_socket_homedir; end
    def unix_domain_socket_tmpdir; end
    def warn(msg); end
  end
end

class DEBUGGER__::Breakpoint
  include ::DEBUGGER__::SkipPathHelper
  include ::DEBUGGER__::Color

  def initialize(cond, command, path, do_enable: T.unsafe(nil)); end

  def delete; end
  def deleted?; end
  def description; end
  def disable; end
  def duplicable?; end
  def enable; end
  def enabled?; end
  def generate_label(name); end
  def key; end
  def oneshot?; end
  def safe_eval(b, expr); end
  def setup; end
  def skip_path?(path); end
  def suspend; end
  def to_s; end
end

DEBUGGER__::CONFIG = T.let(T.unsafe(nil), DEBUGGER__::Config)
DEBUGGER__::CONFIG_MAP = T.let(T.unsafe(nil), Hash)
DEBUGGER__::CONFIG_SET = T.let(T.unsafe(nil), Hash)

class DEBUGGER__::CallTracer < ::DEBUGGER__::Tracer
  def setup; end
  def skip_with_pattern?(tp); end
end

class DEBUGGER__::CatchBreakpoint < ::DEBUGGER__::Breakpoint
  def initialize(pat, cond: T.unsafe(nil), command: T.unsafe(nil), path: T.unsafe(nil)); end

  def description; end
  def last_exc; end
  def setup; end
  def to_s; end
end

class DEBUGGER__::CheckBreakpoint < ::DEBUGGER__::Breakpoint
  def initialize(cond:, command: T.unsafe(nil), path: T.unsafe(nil)); end

  def setup; end
  def to_s; end

  private

  def need_suspend?(cond_result); end
end

module DEBUGGER__::Color
  def color_pp(obj, width); end
  def colored_inspect(obj, width: T.unsafe(nil), no_color: T.unsafe(nil)); end
  def colorize(str, color); end
  def colorize_blue(str); end
  def colorize_code(code); end
  def colorize_cyan(str); end
  def colorize_dim(str); end
  def colorize_magenta(str); end
  def irb_colorize(str, color); end
  def with_inspection_error_guard; end
end

DEBUGGER__::Color::SUPPORT_COLORABLE_OPTION = T.let(T.unsafe(nil), TrueClass)

class DEBUGGER__::Config
  def initialize(argv); end

  def [](key); end
  def []=(key, val); end
  def append_config(key, val); end
  def inspect; end
  def set_config(**kw); end
  def skip?; end
  def skip_all; end
  def update(conf); end

  private

  def config; end
  def disable_sigdump(old_sig); end
  def enable_sigdump(sig); end
  def if_updated(old_conf, new_conf, key); end
  def parse_config_value(name, valstr); end
  def setup_sigdump(old_sig = T.unsafe(nil), sig = T.unsafe(nil)); end

  class << self
    def config; end
    def config_to_env_hash(config); end
    def parse_argv(argv); end
    def parse_config_value(name, valstr); end
  end
end

class DEBUGGER__::Console
  include ::DEBUGGER__::Color

  def initialize; end

  def deactivate; end
  def history; end
  def history_file; end
  def load_history; end
  def load_history_if_not_loaded; end
  def parse_input(buff, commands); end
  def read_history_file; end
  def readline(prompt); end
  def readline_setup(prompt); end

  private

  def get_command(line); end
end

DEBUGGER__::Console::FH = T.let(T.unsafe(nil), String)
DEBUGGER__::Console::SIGWINCH_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

class DEBUGGER__::ExceptionTracer < ::DEBUGGER__::Tracer
  def setup; end
  def skip_with_pattern?(tp); end
end

module DEBUGGER__::ForkInterceptor
  def _fork; end

  private

  def __fork_setup_for_debugger; end
end

class DEBUGGER__::FrameInfo < ::Struct
  def _callee; end
  def _callee=(_); end
  def _local_variables; end
  def _local_variables=(_); end
  def binding; end
  def binding=(_); end
  def block_identifier; end
  def c_identifier; end
  def callee; end
  def class; end
  def class=(_); end
  def dupped_binding; end
  def dupped_binding=(_); end
  def eval_binding; end
  def file_lines; end
  def frame_depth; end
  def frame_depth=(_); end
  def frame_type; end
  def has_raised_exception; end
  def has_raised_exception=(_); end
  def has_return_value; end
  def has_return_value=(_); end
  def iseq; end
  def iseq=(_); end
  def local_variables; end
  def location; end
  def location=(_); end
  def location_str; end
  def matchable_location; end
  def method_identifier; end
  def name; end
  def other_identifier; end
  def parameters_info; end
  def path; end
  def pretty_path; end
  def raised_exception; end
  def raised_exception=(_); end
  def realpath; end
  def return_str; end
  def return_value; end
  def return_value=(_); end
  def self; end
  def self=(_); end
  def show_line; end
  def show_line=(_); end

  private

  def get_singleton_class(obj); end
  def klass_sig; end
  def local_variable_get(var); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
    def pretty_path(path); end
  end
end

DEBUGGER__::FrameInfo::BLOCK_LABL_REGEXP = T.let(T.unsafe(nil), Regexp)
DEBUGGER__::FrameInfo::HOME = T.let(T.unsafe(nil), String)

class DEBUGGER__::ISeqBreakpoint < ::DEBUGGER__::Breakpoint
  def initialize(iseq, events, oneshot: T.unsafe(nil)); end

  def enable; end
  def setup; end
end

DEBUGGER__::LOG_LEVELS = T.let(T.unsafe(nil), Hash)

class DEBUGGER__::LimitedPP
  def initialize(max); end

  def <<(other); end
  def buf; end

  class << self
    def pp(obj, max = T.unsafe(nil)); end
  end
end

class DEBUGGER__::LineBreakpoint < ::DEBUGGER__::Breakpoint
  def initialize(path, line, cond: T.unsafe(nil), oneshot: T.unsafe(nil), hook_call: T.unsafe(nil), command: T.unsafe(nil), skip_activate: T.unsafe(nil)); end

  def activate(iseq, event, line); end
  def activate_exact(iseq, events, line); end
  def command; end
  def cond; end
  def duplicable?; end
  def enable; end
  def hook_call; end
  def inspect; end
  def iseq; end
  def iterate_iseq(root_iseq); end
  def line; end
  def oneshot; end
  def path; end
  def setup; end
  def to_s; end
  def try_activate(root_iseq = T.unsafe(nil)); end

  class << self
    def copy(bp, root_iseq); end
  end
end

class DEBUGGER__::LineBreakpoint::NearestISeq < ::Struct
  def events; end
  def events=(_); end
  def iseq; end
  def iseq=(_); end
  def line; end
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class DEBUGGER__::LineTracer < ::DEBUGGER__::Tracer
  def setup; end
end

DEBUGGER__::M_CLASS = T.let(T.unsafe(nil), UnboundMethod)
DEBUGGER__::M_INSTANCE_VARIABLES = T.let(T.unsafe(nil), UnboundMethod)
DEBUGGER__::M_INSTANCE_VARIABLE_GET = T.let(T.unsafe(nil), UnboundMethod)
DEBUGGER__::M_KIND_OF_P = T.let(T.unsafe(nil), UnboundMethod)
DEBUGGER__::M_METHOD = T.let(T.unsafe(nil), UnboundMethod)
DEBUGGER__::M_OBJECT_ID = T.let(T.unsafe(nil), UnboundMethod)
DEBUGGER__::M_RESPOND_TO_P = T.let(T.unsafe(nil), UnboundMethod)
DEBUGGER__::M_SINGLETON_CLASS = T.let(T.unsafe(nil), UnboundMethod)

class DEBUGGER__::MethodBreakpoint < ::DEBUGGER__::Breakpoint
  def initialize(b, klass_name, op, method_name, cond: T.unsafe(nil), command: T.unsafe(nil), path: T.unsafe(nil)); end

  def enable; end
  def eval_class_name; end
  def klass; end
  def method; end
  def override(klass); end
  def search_method; end
  def setup; end
  def sig; end
  def sig_method_name; end
  def to_s; end
  def try_enable(added: T.unsafe(nil)); end
end

module DEBUGGER__::MultiProcessGroup
  def after_fork(child: T.unsafe(nil)); end
  def info(msg); end
  def lock; end
  def locked?; end
  def multi_process!; end
  def sync(&b); end
  def unlock; end

  private

  def lock_level_down; end
  def lock_level_up; end
  def trylock; end
end

class DEBUGGER__::ObjectTracer < ::DEBUGGER__::Tracer
  def initialize(ui, obj_id, obj_inspect, **kw); end

  def colorized_obj_inspect; end
  def description; end
  def setup; end
end

class DEBUGGER__::PostmortemError < ::RuntimeError; end

class DEBUGGER__::PresetCommand < ::Struct
  def auto_continue; end
  def auto_continue=(_); end
  def commands; end
  def commands=(_); end
  def source; end
  def source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class DEBUGGER__::ProcessGroup
  def initialize; end

  def after_fork; end
  def lock; end
  def locked?; end
  def multi?; end
  def multi_process!; end
  def sync; end
  def trylock; end
  def unlock; end
end

DEBUGGER__::SESSION = T.let(T.unsafe(nil), DEBUGGER__::Session)
DEBUGGER__::SHORT_INSPECT_LENGTH = T.let(T.unsafe(nil), Integer)
DEBUGGER__::SO_VERSION = T.let(T.unsafe(nil), String)

class DEBUGGER__::Session
  include ::DEBUGGER__::Color

  def initialize; end

  def activate(ui = T.unsafe(nil), on_fork: T.unsafe(nil)); end
  def active?; end
  def add_bp(bp); end
  def add_catch_breakpoint(pat, cond: T.unsafe(nil)); end
  def add_check_breakpoint(cond, path, command); end
  def add_iseq_breakpoint(iseq, **kw); end
  def add_line_breakpoint(file, line, **kw); end
  def add_preset_commands(name, cmds, kick: T.unsafe(nil), continue: T.unsafe(nil)); end
  def add_tracer(tracer); end
  def after_fork_parent; end
  def ask(msg, default = T.unsafe(nil)); end
  def before_fork(need_lock = T.unsafe(nil)); end
  def bp_index(specific_bp_key); end
  def break_at?(file, line); end
  def cancel_auto_continue; end
  def capture_exception_frames(*exclude_path); end
  def check_postmortem; end
  def clean_bps; end
  def clear_all_breakpoints; end
  def clear_breakpoints(&condition); end
  def clear_catch_breakpoints(*exception_names); end
  def clear_line_breakpoints(path); end
  def config_command(arg); end
  def config_set(key, val, append: T.unsafe(nil)); end
  def config_show(key); end
  def deactivate; end
  def delete_bp(arg = T.unsafe(nil)); end
  def enter_postmortem_session(exc); end
  def get_thread_client(th = T.unsafe(nil)); end
  def in_subsession?; end
  def inspect; end
  def intercept_trap_sigint(flag, &b); end
  def intercept_trap_sigint?; end
  def intercept_trap_sigint_end; end
  def intercept_trap_sigint_start(prev); end
  def intercepted_sigint_cmd; end
  def iterate_bps; end
  def managed_thread_clients; end
  def method_added(tp); end
  def on_load(iseq, src); end
  def on_thread_begin(th); end
  def parse_break(arg); end
  def pop_event; end
  def postmortem=(is_enable); end
  def process_command(line); end
  def process_event(evt); end
  def process_group; end
  def process_info; end
  def prompt; end
  def rehash_bps; end
  def repl_add_breakpoint(arg); end
  def repl_add_catch_breakpoint(arg); end
  def repl_add_watch_breakpoint(arg); end
  def repl_open; end
  def repl_open_setup; end
  def repl_open_tcp(host, port, **kw); end
  def repl_open_vscode; end
  def request_tc(req); end
  def reset_ui(ui); end
  def resolve_path(file); end
  def save_int_trap(cmd); end
  def session_server_main; end
  def setup_threads; end
  def show_bps(specific_bp = T.unsafe(nil)); end
  def show_help(arg = T.unsafe(nil)); end
  def source(iseq); end
  def step_command(type, arg); end
  def switch_thread(n); end
  def thread_list; end
  def update_thread_list; end
  def wait_command; end
  def wait_command_loop; end
  def width; end

  private

  def ask_thread_client(th); end
  def create_thread_client(th); end
  def enter_subsession; end
  def leave_subsession(type); end
  def restart_all_threads; end
  def running_thread_clients_count; end
  def stop_all_threads; end
  def thread_stopper; end
  def waiting_thread_clients; end

  class << self
    def activate_method_added_trackers; end
    def create_method_added_tracker(mod, method_added_id, method_accessor = T.unsafe(nil)); end
    def deactivate_method_added_trackers; end
  end
end

DEBUGGER__::Session::BREAK_KEYWORDS = T.let(T.unsafe(nil), Array)
DEBUGGER__::Session::METHOD_ADDED_TRACKERS = T.let(T.unsafe(nil), Hash)

module DEBUGGER__::SkipPathHelper
  def skip_config_skip_path?(path); end
  def skip_internal_path?(path); end
  def skip_location?(loc); end
  def skip_path?(path); end
end

class DEBUGGER__::SourceRepository
  include ::DEBUGGER__::Color

  def initialize; end

  def add(iseq, src); end
  def get(iseq); end
  def get_colored(iseq); end
end

class DEBUGGER__::ThreadClient
  include ::DEBUGGER__::Color
  include ::DEBUGGER__::SkipPathHelper

  def initialize(id, q_evt, q_cmd, thr = T.unsafe(nil)); end

  def <<(req); end
  def assemble_arguments(args); end
  def check_bp_fulfillment_map; end
  def class_method_map(classes); end
  def close; end
  def collect_locals(frame); end
  def constant_name?(name); end
  def current_frame; end
  def deactivate; end
  def debug_cmd(cmds); end
  def debug_event(ev, args); end
  def debug_mode(old_mode, new_mode); end
  def debug_suspend(event); end
  def default_frame_formatter(frame); end
  def event!(ev, *args); end
  def frame_eval(src, re_raise: T.unsafe(nil)); end
  def frame_eval_core(src, b); end
  def frame_str(i, frame: T.unsafe(nil)); end
  def generate_info; end
  def get_frame(index); end
  def get_src(frame, max_lines:, start_line: T.unsafe(nil), end_line: T.unsafe(nil), dir: T.unsafe(nil)); end
  def id; end
  def inspect; end
  def location; end
  def make_breakpoint(args); end
  def management?; end
  def mark_as_management; end
  def name; end
  def on_breakpoint(tp, bp); end
  def on_init(name); end
  def on_load(iseq, eval_src); end
  def on_pause; end
  def on_trace(trace_id, msg); end
  def on_trap(sig); end
  def outline_method(o, klass, obj); end
  def puts(str = T.unsafe(nil)); end
  def puts_variable_info(label, obj, pat); end
  def recorder; end
  def replay_suspend; end
  def running?; end
  def set_mode(mode); end
  def show_by_editor(path = T.unsafe(nil)); end
  def show_consts(pat, only_self: T.unsafe(nil)); end
  def show_frame(i = T.unsafe(nil)); end
  def show_frames(max = T.unsafe(nil), pattern = T.unsafe(nil)); end
  def show_globals(pat); end
  def show_ivars(pat); end
  def show_locals(pat); end
  def show_outline(expr); end
  def show_src(frame_index: T.unsafe(nil), update_line: T.unsafe(nil), max_lines: T.unsafe(nil), **options); end
  def special_local_variables(frame); end
  def step_tp(iter, events = T.unsafe(nil)); end
  def suspend(event, tp = T.unsafe(nil), bp: T.unsafe(nil), sig: T.unsafe(nil), postmortem_frames: T.unsafe(nil), replay_frames: T.unsafe(nil), postmortem_exc: T.unsafe(nil)); end
  def thread; end
  def to_s; end
  def tp_allow_reentry; end
  def truncate(string, width:); end
  def wait_next_action; end
  def wait_next_action_; end
  def wait_reply(event_arg); end
  def waiting?; end

  class << self
    def current; end
  end
end

class DEBUGGER__::ThreadClient::Output
  include ::DEBUGGER__::Color

  def initialize(output); end

  def dump(name, strs); end

  private

  def col_widths(strs, cols:); end
  def fits_on_line?(strs, cols:, offset: T.unsafe(nil)); end
  def screen_width; end
end

DEBUGGER__::ThreadClient::Output::MARGIN = T.let(T.unsafe(nil), String)

class DEBUGGER__::ThreadClient::Recorder
  include ::DEBUGGER__::SkipPathHelper

  def initialize; end

  def backup_frames; end
  def backup_frames=(_arg0); end
  def can_step_back?; end
  def current_frame; end
  def current_position; end
  def disable; end
  def enable; end
  def enabled?; end
  def index; end
  def log; end
  def log_index; end
  def replaying?; end
  def step_back; end
  def step_forward; end
  def step_reset; end
end

DEBUGGER__::ThreadClient::SKIP_GLOBAL_LIST = T.let(T.unsafe(nil), Array)
DEBUGGER__::ThreadClient::SPECIAL_LOCAL_VARS = T.let(T.unsafe(nil), Array)
DEBUGGER__::ThreadClient::SUPPORT_TARGET_THREAD = T.let(T.unsafe(nil), TrueClass)
class DEBUGGER__::ThreadClient::SuspendReplay < ::Exception; end

class DEBUGGER__::Tracer
  include ::DEBUGGER__::SkipPathHelper
  include ::DEBUGGER__::Color

  def initialize(ui, pattern: T.unsafe(nil), into: T.unsafe(nil)); end

  def colorize(str, color); end
  def description; end
  def disable; end
  def enable; end
  def header(depth); end
  def key; end
  def minfo(tp); end
  def out(tp, msg = T.unsafe(nil), depth = T.unsafe(nil)); end
  def puts(msg); end
  def skip?(tp); end
  def skip_with_pattern?(tp); end
  def to_s; end
  def type; end
end

module DEBUGGER__::TrapInterceptor
  def trap(sig, *command, &command_proc); end
end

class DEBUGGER__::UI_Base
  def event(type, *args); end
  def flush; end
end

class DEBUGGER__::UI_LocalConsole < ::DEBUGGER__::UI_Base
  def initialize; end

  def activate(session, on_fork: T.unsafe(nil)); end
  def after_fork_parent; end
  def ask(prompt); end
  def deactivate; end
  def puts(str = T.unsafe(nil)); end
  def quit(n); end
  def readline(prompt = T.unsafe(nil)); end
  def remote?; end
  def setup_interrupt; end
  def width; end
end

class DEBUGGER__::WatchIVarBreakpoint < ::DEBUGGER__::Breakpoint
  def initialize(ivar, object, current, cond: T.unsafe(nil), command: T.unsafe(nil), path: T.unsafe(nil)); end

  def setup; end
  def to_s; end
  def watch_eval(tp); end
end

module IRB::Color
  class << self
    def clear(colorable: T.unsafe(nil)); end
    def colorable?; end
    def colorize(text, seq, colorable: T.unsafe(nil)); end
    def colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil), local_variables: T.unsafe(nil)); end
    def inspect_colorable?(obj, seen: T.unsafe(nil)); end

    private

    def dispatch_seq(token, expr, str, in_symbol:); end
    def scan(code, allow_last_error:); end
    def without_circular_ref(obj, seen:, &block); end
  end
end

IRB::Color::BLUE = T.let(T.unsafe(nil), Integer)
IRB::Color::BOLD = T.let(T.unsafe(nil), Integer)
IRB::Color::CLEAR = T.let(T.unsafe(nil), Integer)
IRB::Color::CYAN = T.let(T.unsafe(nil), Integer)
IRB::Color::DIM = T.let(T.unsafe(nil), Integer)
IRB::Color::GREEN = T.let(T.unsafe(nil), Integer)
IRB::Color::MAGENTA = T.let(T.unsafe(nil), Integer)
IRB::Color::RED = T.let(T.unsafe(nil), Integer)
IRB::Color::REVERSE = T.let(T.unsafe(nil), Integer)
IRB::Color::UNDERLINE = T.let(T.unsafe(nil), Integer)
IRB::Color::YELLOW = T.let(T.unsafe(nil), Integer)

module Kernel
  def debugger(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin

  def traceable_lines_norec(lines); end
  def traceable_lines_rec(lines); end
end
