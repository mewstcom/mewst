# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq`.

module Sidekiq
  class << self
    def configure_client; end
    def configure_embed(&block); end
    def configure_server(&block); end
    def default_configuration; end
    def default_job_options; end
    def default_job_options=(hash); end
    def dump_json(object); end
    def ent?; end
    def freeze!; end
    def load_json(string); end
    def logger; end
    def pro?; end
    def redis(&block); end
    def redis_pool; end
    def server?; end
    def strict_args!(mode = T.unsafe(nil)); end
    def transactional_push!; end
  end
end

class Sidekiq::Client
  include ::Sidekiq::JobUtil

  def initialize(*args, **kwargs); end

  def middleware(&block); end
  def push(item); end
  def push_bulk(items); end
  def redis_pool; end
  def redis_pool=(_arg0); end

  private

  def atomic_push(conn, payloads); end
  def raw_push(payloads); end

  class << self
    def enqueue(klass, *args); end
    def enqueue_in(interval, klass, *args); end
    def enqueue_to(queue, klass, *args); end
    def enqueue_to_in(queue, interval, klass, *args); end
    def push(item); end
    def push_bulk(items); end
    def via(pool); end
  end
end

Sidekiq::ClientMiddleware = Sidekiq::ServerMiddleware

class Sidekiq::Config
  extend ::Forwardable

  def initialize(options = T.unsafe(nil)); end

  def [](*args, **_arg1, &block); end
  def []=(*args, **_arg1, &block); end
  def average_scheduled_poll_interval=(interval); end
  def capsule(name); end
  def capsules; end
  def client_middleware; end
  def concurrency; end
  def concurrency=(val); end
  def death_handlers; end
  def default_capsule(&block); end
  def error_handlers; end
  def fetch(*args, **_arg1, &block); end
  def handle_exception(ex, ctx = T.unsafe(nil)); end
  def has_key?(*args, **_arg1, &block); end
  def key?(*args, **_arg1, &block); end
  def logger; end
  def logger=(logger); end
  def lookup(name, default_class = T.unsafe(nil)); end
  def merge!(*args, **_arg1, &block); end
  def new_redis_pool(size, name = T.unsafe(nil)); end
  def on(event, &block); end
  def queues; end
  def queues=(val); end
  def redis; end
  def redis=(hash); end
  def redis_info; end
  def redis_pool; end
  def register(name, instance); end
  def server_middleware; end
  def total_concurrency; end

  private

  def local_redis_pool; end
end

Sidekiq::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)
Sidekiq::Config::ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

module Sidekiq::Context
  class << self
    def add(k, v); end
    def current; end
    def with(hash); end
  end
end

module Sidekiq::Job
  include ::Sidekiq::Job::Options

  mixes_in_class_methods ::Sidekiq::Job::Options::ClassMethods
  mixes_in_class_methods ::Sidekiq::Job::ClassMethods

  def jid; end
  def jid=(_arg0); end
  def logger; end

  class << self
    def included(base); end
  end
end

module Sidekiq::Job::ClassMethods
  def build_client; end
  def client_push(item); end
  def delay(*args); end
  def delay_for(*args); end
  def delay_until(*args); end
  def perform_async(*args); end
  def perform_at(interval, *args); end
  def perform_bulk(*args, **kwargs); end
  def perform_in(interval, *args); end
  def perform_inline(*args); end
  def perform_sync(*args); end
  def queue_as(q); end
  def set(options); end
  def sidekiq_options(opts = T.unsafe(nil)); end
end

module Sidekiq::Job::Options
  mixes_in_class_methods ::Sidekiq::Job::Options::ClassMethods

  class << self
    def included(base); end
  end
end

module Sidekiq::Job::Options::ClassMethods
  def get_sidekiq_options; end
  def sidekiq_class_attribute(*attrs); end
  def sidekiq_options(opts = T.unsafe(nil)); end
  def sidekiq_retries_exhausted(&block); end
  def sidekiq_retry_in(&block); end
end

Sidekiq::Job::Options::ClassMethods::ACCESSOR_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

class Sidekiq::Job::Setter
  include ::Sidekiq::JobUtil

  def initialize(klass, opts); end

  def perform_async(*args); end
  def perform_at(interval, *args); end
  def perform_bulk(args, batch_size: T.unsafe(nil)); end
  def perform_in(interval, *args); end
  def perform_inline(*args); end
  def perform_sync(*args); end
  def set(options); end

  private

  def at(interval); end
end

module Sidekiq::JobUtil
  def normalize_item(item); end
  def normalized_hash(item_class); end
  def validate(item); end
  def verify_json(item); end

  private

  def json_safe?(item); end
end

Sidekiq::JobUtil::TRANSIENT_ATTRIBUTES = T.let(T.unsafe(nil), Array)
Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

class Sidekiq::Logger < ::Logger
  include ::Sidekiq::LoggingUtils
end

module Sidekiq::Logger::Formatters; end

class Sidekiq::Logger::Formatters::Base < ::Logger::Formatter
  def ctx; end
  def format_context; end
  def tid; end
end

class Sidekiq::Logger::Formatters::JSON < ::Sidekiq::Logger::Formatters::Base
  def call(severity, time, program_name, message); end
end

class Sidekiq::Logger::Formatters::Pretty < ::Sidekiq::Logger::Formatters::Base
  def call(severity, time, program_name, message); end
end

class Sidekiq::Logger::Formatters::WithoutTimestamp < ::Sidekiq::Logger::Formatters::Pretty
  def call(severity, time, program_name, message); end
end

module Sidekiq::LoggingUtils
  def debug?; end
  def error?; end
  def fatal?; end
  def info?; end
  def level; end
  def local_level; end
  def local_level=(level); end
  def log_at(level); end
  def warn?; end
end

Sidekiq::LoggingUtils::LEVELS = T.let(T.unsafe(nil), Hash)
Sidekiq::MAJOR = T.let(T.unsafe(nil), Integer)
module Sidekiq::Middleware; end

class Sidekiq::Middleware::Chain
  include ::Enumerable

  def initialize(config = T.unsafe(nil)); end

  def add(klass, *args); end
  def clear; end
  def copy_for(capsule); end
  def each(&block); end
  def empty?; end
  def entries; end
  def exists?(klass); end
  def include?(klass); end
  def insert_after(oldklass, newklass, *args); end
  def insert_before(oldklass, newklass, *args); end
  def invoke(*args); end
  def prepend(klass, *args); end
  def remove(klass); end
  def retrieve; end
end

class Sidekiq::Middleware::Entry
  def initialize(config, klass, *args); end

  def klass; end
  def make_new; end
end

Sidekiq::NAME = T.let(T.unsafe(nil), String)
class Sidekiq::Rails < ::Rails::Engine; end

class Sidekiq::Rails::Reloader
  def initialize(app = T.unsafe(nil)); end

  def call; end
  def inspect; end
end

class Sidekiq::RedisClientAdapter
  def initialize(options); end

  def new_client; end

  private

  def client_opts(options); end
end

Sidekiq::RedisClientAdapter::BaseError = RedisClient::Error
Sidekiq::RedisClientAdapter::CommandError = RedisClient::CommandError

class Sidekiq::RedisClientAdapter::CompatClient < ::RedisClient::Decorator::Client
  include ::Sidekiq::RedisClientAdapter::CompatMethods

  def config; end
  def message; end
  def subscribe(chan); end
end

class Sidekiq::RedisClientAdapter::CompatClient::Pipeline < ::RedisClient::Decorator::Pipeline
  include ::Sidekiq::RedisClientAdapter::CompatMethods
end

module Sidekiq::RedisClientAdapter::CompatMethods
  def evalsha(sha, keys, argv); end
  def info; end

  private

  def method_missing(*args, **_arg1, &block); end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module Sidekiq::RedisConnection
  class << self
    def create(options = T.unsafe(nil)); end

    private

    def determine_redis_provider; end
    def scrub(options); end
  end
end

module Sidekiq::ServerMiddleware
  def config; end
  def config=(_arg0); end
  def logger; end
  def redis(&block); end
  def redis_pool; end
end

class Sidekiq::Shutdown < ::Interrupt; end

class Sidekiq::TransactionAwareClient
  def initialize(pool: T.unsafe(nil), config: T.unsafe(nil)); end

  def push(item); end
  def push_bulk(items); end
end

Sidekiq::VERSION = T.let(T.unsafe(nil), String)
Sidekiq::Worker = Sidekiq::Job
